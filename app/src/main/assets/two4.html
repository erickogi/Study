<html>
	<meta charset="UTF-8">
	<style>
	
	  @font-face {
                    font-family: "ebrima";
                    src: url('file:///android_asset/fonts/ebrima.TTF');
                }
		body{
			font-family: ebrima, Tahoma, "Arial Black";
		    font-size: 16px;		    
		    word-wrap: normal;		
		}
		p{
			line-height:22px;
			padding-bottom:10px;			
		}
		h3, h4{
			font-family: ebrima, Tahoma, "Arial Black";
			color:#2c3e4c;
			padding-bottom:3px;
			border-bottom: 1px solid #444343;
			font-weight:650;
		}
		td{
			padding:10px;
			border: 1px solid #2c3e4c;
		}
		
		.erb-image-wrapper{
			max-width:100%;
            height:auto;
            position: relative;
            display:block;
            margin:0 auto;
        }
        
        .erb-image-wrapper img{
        	max-width:100% !important;
            height:auto;
            display:block;
         }	
	
</style>
   <body>
<h3>.	The Waterfall Model</h3>
<p>It is a sequential design process, used in software development processes, in which progress is seen as flowing steadily downwards through the phases of Conception, Initiation, Analysis, Design, Construction, Testing, Production/Implementation and Maintenance.</p>


<p>Advantages of the Waterfall Model</p>
<p>1	Dependence on individuals is minimzed.</p>
<p>2	Quality control is easier</p>
<p>3	 Cost control is manageable</p>
<p>4	This model is simple and easy to understand and use.</p>
<p>5	It is easy to manage due to the rigidity of the model – each phase has specific deliverables and a review process.</p>
<p>6	In this model phases are processed and completed one at a time. Phases do not overlap.</p>
<p>7	Waterfall model works well for smaller projects where requirements are very well understood.</p>

<h4>Problems of Waterfall Model</h4>
<p>1	The main drawback of the waterfall model is the difficulty of accommodating change after the process is underway. One phase has to be complete before moving onto the next phase.</p>
<p>2	Each stage in the process reveals new understanding of the previous stages, that requires the earlier stages to be revised.</p>
<p>3	Inflexible partitioning of the project into distinct stages makes it difficult to respond to changing customer requirements.</p> 
<p>4	No working software is produced until late during the life cycle.</p>
<p>5	Not suitable for the projects where requirements are at a moderate to high risk of changing.</p>
<p>6	High amounts of risk and uncertainty.</p>
<p>7	Not a good model for complex and object-oriented projects.</p>
<p>8	Poor model for long and ongoing projects.</p>
<p><i>When to use this model.</i></p>
<p>•	This model is only appropriate when the requirements are well-understood and changes will be fairly limited during the design process. </p>
<p>•	Product definition is stable - Few business systems have stable requirements.</p>
<p>•	This waterfall model is mostly used for large systems engineering projects where a system is developed at several sites. </p>
<p>•	Technology is understood.</p> 
<p>•	There are no ambiguous requirements</p> 
<p>•	Ample resources with required expertise are available freely </p>
<p>•	The project is short.</p>

<h3>2.	 Iterative Refinement (Evolutionary Development)</h3>
<p>It does not attempt to start with a full specification of requirements.<br/> Instead, development begins by specifying and implementing just part of the software, which can then be reviewed in order to identify further requirements. <br/>This process is then repeated, producing a new version of the software for each cycle of the model.</p>
 <div class="erb-image-wrapper">
<img src="file:///android_asset/iterative.png" alt="iterative model" />
</div>

<h4>Advantages of Iterative model:</h4>
<p>•	We can only create a high-level design of the application before we actually begin to build the product and define the design solution for the entire product.<br/> Later on we can design and built a skeleton version of that, and then evolved the design based on what had been built.</p>
<p>•	In iterative model we are building and improving the product step by step. Hence we can track the defects at early stages.<br/> This avoids the downward flow of the defects.</p>
<p>•	In iterative model we can get the reliable user feedback. When presenting sketches and blueprints of the product to users for their feedback, we are effectively asking them to imagine how the product will work.</p>
<p>•	In iterative model less time is spent on documenting and more time is given for designing.
</p>
<h4>Disadvantages of Iterative model:  </h4>
<p>•	Each phase of an iteration is rigid with no overlaps</p>
<p>•	Costly system architecture or design issues may arise because not all requirements are gathered up front for the entire lifecycle</p>

<h4>When to use iterative model:</h4>
<p>•	Requirements of the complete system are clearly defined and understood. </p>
<p>•	When the project is big.</p>
<p>•	Major requirements must be defined; however, some details can evolve with time.</p>
<p><i>next v & incremental models</i></p>



<br/>
   	<br/>
<br/>
</body>
</html>