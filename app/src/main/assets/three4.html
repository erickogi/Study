<html>
	<meta charset="UTF-8">
	<style>
	
	  @font-face {
                    font-family: "ebrima";
                    src: url('file:///android_asset/fonts/ebrima.TTF');
                }
		body{
			font-family: ebrima, Tahoma, "Arial Black";
		    font-size: 16px;		    
		    word-wrap: normal;		
		}
		p{
			line-height:22px;
			padding-bottom:10px;			
		}
		h3, h4{
			font-family: ebrima, Tahoma, "Arial Black";
			color:#2c3e4c;
			padding-bottom:3px;
			border-bottom: 1px solid #444343;
			font-weight:650;
		}
		td{
			padding:10px;
			border: 1px solid #2c3e4c;
		}
		
		.erb-image-wrapper{
			max-width:100%;
            height:auto;
            position: relative;
            display:block;
            margin:0 auto;
        }
        
        .erb-image-wrapper img{
        	max-width:100% !important;
            height:auto;
            display:block;
         }	
	
</style>
   <body>
<h3>V-model</h3>
<p>V- model means Verification and Validation model. <br/>Just like the waterfall model, the V-Shaped life cycle is a sequential path of execution of processes.<br/> Each phase must be completed before the next phase begins.  Testing of the product is planned in parallel with a corresponding phase of development.</p>
 
<p><i>The various phases of the V-model are as follows:</i></p>
<p>.The high-level design (HLD) phase focuses on system architecture and design. It provide overview of solution, platform, system, product and service/process.</p> 
<p>.The low-level design (LLD) phase is where the actual software components are designed.<br/> It defines the actual logic for each and every component of the system. <br/>Class diagram with all the methods and relation between classes comes under LLD. Component tests are created in this phase as well.<br/>
The implementation phase is, again, where all coding takes place. Once coding is complete, the path of execution continues up the right side of the V where the test plans developed earlier are now put to use.</p>
<p>Coding: Module design is converted into code by developers.</p>
<div class="erb-image-wrapper">
<img src="file:///android_asset/v.png" alt="v model" />
</div>
<h4>Advantages of V-model:</h4>
<p>•	Simple and easy to use.</p>
<p>•	Testing activities like planning, test designing happens well before coding.<br/> This saves a lot of time. Hence higher chance of success over the waterfall model.</p>
<p>•	Proactive defect tracking – that is defects are found at early stage.</p>
<p>•	Avoids the downward flow of the defects.</p>
<p>•	Works well for small projects where requirements are easily understood.</p>

<h4>Disadvantages of V-model:</h4>
<p>•	Very rigid and least flexible.</p>
<p>•	Software is developed during the implementation phase, so no early prototypes of the software are produced.</p>
<p>•	If any changes happen in midway, then the test documents along with requirement documents has to be updated.</p>

<h4>When to use the V-model:</h4>
<p>•	The V-shaped model should be used for small to medium sized projects where requirements are clearly defined and fixed.</p>
<p>•	The V-Shaped model should be chosen when ample technical resources are available with needed technical expertise.</p>
<p>High confidence of customer is required for choosing the V-Shaped model approach. Since, no prototypes are produced, there is a very high risk involved in meeting customer expectations.</p>

<h3>Incremental model</h3>
<p>The whole requirement is divided into various builds. <br/>Multiple development cycles take place here, making the life cycle a “multi-waterfall” cycle. <br/> Cycles are divided up into smaller, more easily managed modules.  Each module passes through the requirements, design, implementation and testing phases. A working version of software is produced during the first module, so you have working software early on during the software life cycle.</p> 
<p>Each subsequent release of the module adds function to the previous release. The process continues till the complete system is achieved.</p>
  <div class="erb-image-wrapper">
<img src="file:///android_asset/incremental.png" alt="incremental" />
</div>
<h4>dvantages of Incremental model:</h4>
<P>•	Generates working software quickly and early during the software life cycle.</P>
<P>•	This model is more flexible – less costly to change scope and requirements.</p>
<P>•	It is easier to test and debug during a smaller iteration.</P>
<p>•	In this model customer can respond to each built.</p>
<p>•	Lowers initial delivery cost.</p>
<p>•	Easier to manage risk because risky pieces are identified and handled during it’d iteration.</p>

<h4>Disadvantages of Incremental model:</h4>
<p>•	Needs good planning and design.</p>
<p>•	Needs a clear and complete definition of the whole system before it can be broken down and built incrementally.</p>
<p>•	Total cost is higher than waterfall.</p>
<h4>When to use the Incremental model:</h4>
<p>•	This model can be used when the requirements of the complete system are clearly defined and understood. </p>
<p>•	Major requirements must be defined; however, some details can evolve with time.</p> 
<p>•	There is a need to get a product to the market early.</p>
<p>•	A new technology is being used</p>
<p>•	Resources with needed skill set are not available</p>
<p>•	There are some high risk features and goals.</p>
<p><i>next rad &agile models</i></p>
<br/>
   	<br/>
<br/>
</body>
</html>