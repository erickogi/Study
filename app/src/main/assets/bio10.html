<html>
	<meta charset="UTF-8">
	<style>
	
	  @font-face {
                    font-family: "ebrima";
                    src: url('file:///android_asset/fonts/ebrima.TTF');
                }
		body{
			font-family: ebrima, Tahoma, "Arial Black";
		    font-size: 16px;		    
		    word-wrap: normal;		
		}
		p{
			line-height:22px;
			padding-bottom:10px;			
		}
		h3, h4{
			font-family: ebrima, Tahoma, "Arial Black";
			color:#2c3e4c;
			padding-bottom:3px;
			border-bottom: 1px solid #444343;
			font-weight:650;
		}
		td{
			padding:10px;
			border: 1px solid #2c3e4c;
		}
		
		.erb-image-wrapper{
			max-width:100%;
            height:auto;
            position: relative;
            display:block;
            margin:0 auto;
        }
        
        .erb-image-wrapper img{
        	max-width:100% !important;
            height:auto;
            display:block;
         }	
	
</style>
   <body>
<h1>LECTURE 1 - What is Software?</h1>
<h3>Definitions:</h3>
<p>•	The organization of a set of tasks and functionality encapsulated into a form that is executable on a computer.</p>
<p>•	Computer programs, procedures, algorithms and associated documentation such as requirements, design models and user manuals.</p>
<p>•	Programs are an ordered sequence of instructions for changing the state of the computer in a particular sequence.</p>
<p>•	Programs usually written in High Level Languages that are easier and more efficient for humans to use than machine language.
</p>
<h3>Classification of Software</h3>
<p>
<p>1.	Generic – developed to be sold to a range of different customers</p>
<p>2.	Bespoke (Custom) – developed for a single customer according to their specification.</p>
<p>3.	Others:</p>
<p>•	Commercial-Off-the-shelf (COTS) – Retail</p>
<p>•	Government-Off-the-shelf (GOTS)<p>
<p>•	Legacy - written in an “Old” Programming Language eg. Cobol, Fortran, C, etc.</p>
<p>•	Proprietary</p>
<p>•	Open-Source</p>
<p>•	Shareware</p>
<p>•	Freeware
</p>
<h3>Types of Software</h3>
<h5>1.	System Software </h5>
<p>•	operating system</p> 
<p>•	utility programs </P>
<p>•	servers<br/> </p>
•	etc 

<h5>2.	Application Software </h5>
<p>•	DBMS</p>
<p>•	Browsers</p>
<p>•	Packages</p>
<h5>3.	Programming Software</h5> 
<p>•	compilers</p>
<p>•	interpreters</p>
<p>•	debuggers</p>
<p>•	linkers</p>
<p>•	text editors</p>
<h3>Nature of Software</h3>
<p>•	Software is flexible: an executable specification of a computation.</p>
<p>•	Software is expensive: all computable functions may be expressed in software. Complex event driven systems may be expressed in software.</p>
<p>•	Software is huge: eg. an operating system may consist of millions of lines of code.</p>
<p>•	Software is complex: software has little regularity or recognizable components found in other complex systems and there are exponentially many paths through the code and changes in one part of the code may have unintended consequences in other equally remote sections of the code.</p>
<p>•	Software is cheap: manufacturing cost is zero, development cost is everything.</p> 
<p>•	Software is never finished: the changing requirements and ease of modification permits the maintenance phase to dominate a software product’s life cycle.</p>
<p>•	Software is easily modified: we can use various development processes to uncover errors in design and the requirements.</p>
<p>•	Software is communication: communication with a machine but also communication between the client, the software architect, the software engineer, and the coder. Software must be readable in order to be evolvable.</p>

<h3>Role of Software</h3>
<p>•	Software is a product as well as a service – a vehicle that delivers a product.</p>
<p>•	As a product, it is different from traditional types of products</p>
<p>•	Intangible - difficult to describe and evaluate</p>
<p>•	Malleable soft, flexible</p>
<p>•	Human intensive - involves only trivial “manufacturing” process</p>
<p>•	It delivers the computing potential embodied by computer hardware or more broadly network of computers accessible by local hardware.</p>
<h5>As a vehicle for delivering products, software acts as the basis for the:</h5>	
<p>1	control of the computer (operating systems)</p>
<p>2	the communications of information (networks) and</p> 
<p>3	the creation and control of other programs (software tools and environments).</p>
<h3>What is Software Engineering?</h3>
<h4>Definitions:</h4>
<p>1	The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software. (IEEE, 1990)</p>
<p>2	A discipline that adopts engineering approaches, such as established methodologies, processes, tools, standards, organization methods, management methods, quality assurance systems, in the development of large-scale software seeking to result in high productivity, low cost, controllable quality, and measurable development schedule.</p>
<p>3	An engineering discipline that is concerned with all aspects of software production. Multi-person construction of multi-version software.</p>

<h3>Difference between Programming and Software Engineering</h3>
<table border="1">
<tr>
<th>Programming</th>
<th>Software Engineering</th>
</tr>
<tr>
<td>: Individual with good skills, fluent in several programming languages, writes complete programs<br/>
:	One person, one computer<br/>
:	Well-defined problem<br/>
:	Programming-in-the-small<br/>
:	Knowledge on: data structures, algorithms<br/>
:	May lack formal training and have minimal exposure to Computer Science	</td>
</tr>
<tr>
<td>:  Individuals with good communication and interpersonal skills, write program components<br/>
:	Team assembles complete program<br/>
:	Translates Requirements into specifications  and can model applications<br/>
:	Familiarity in multiple Application areas – sees Big Picture<br/>
:	Programming-in-the-large<br/>
:	Design Approaches<br/>
:	OO, Modules, etc.<br/>
:	Top-Down/Bottom-Up</td>
</tr>

</table>

<h3>Difference between Computer Science and Software Engineering</h3>
<table border="1">
<tr>
<th>Computer Science</th>
<th>Software Engineering</th>
</tr>
<tr>
<td>:	Is concerned with theories and methods that underlies computer systems and software systems.
:	Hardware, Software, Liveware, etc</td>
<td>Is concerned with the practicalities of developing and delivering useful software.
:	Software
:	Liveware 
:	Knowledge of computer science is essential for software engineers.</td>
</tr>

</table>
<h3>Difference between System Engineering and Software Engineering</h3>
<table border="1">
<tr>
<th>System Engineering</th>
<th>Software Engineering</th>
</tr>
<tr>
<td>:Hardware development, policy and process design, system deployment, software engineering.<br/>
:	System Engineers involved in system specification, architectural design, integration and deployment.</td>
<td>:Part of the process of System Engineering.
:	Developing the software infrastructure, control, applications and databases in the system.</td>
</tr>

</table>


<h3>Challenges facing Software Engineering</h3>
<h4>Software Engineering in the 21st Century faces 3 key challenges;</h4>
<h5>1.	Heterogeneity challenge:<br/></h5>
<p>:	Developing techniques for building software that can cope with heterogeneous platforms and execution environments – integrate new software with older legacy systems.</p>
<h5>2.	Delivery challenge:</h5>
<p>:	Developing techniques that lead to faster delivery of software – shortening delivery times for large and complex systems without compromising system quality.</p>
<h5>3.	Trust challenge:</h5>
<p>	Developing techniques that demonstrate that software can be trusted by its users – software is intertwined with all aspects of our lives.<br/></p>
<h4>WHAT ARE THE OTHER CHALLENGES?</h4>

<p>....................................................................</p>

<h3>Software Evolution</h3>
<p>The process of developing a software product using software engineering principles and methods is referred to as software evolution.<br/> This includes the initial development of software and its maintenance and updates, till desired software product is developed, which satisfies the expected requirements.</p>
 <div class="erb-image-wrapper">
<img src="file:///android_asset/process.png" alt="process" />
</div>
<p>Evolution starts from the requirement gathering process. After which developers create a prototype of the intended software and show it to the users to get their feedback at the early stage of software product development.<br/> The users suggest changes, on which several consecutive updates and maintenance keep on changing too. <br/>This process changes to the original software, till the desired software is accomplished.</p>
<p>Even after the user has desired software in hand, the advancing technology and the changing requirements force the software product to change accordingly. <br/>Re-creating software from scratch and to go one-on-one with requirement is not feasible. <br/>The only feasible and economical solution is to update the existing software so that it matches the latest requirements.</p>
<h5>SUMMARY</h5>
<h3>SOFTWARE ENGINEERING LIFE CYCLE</h3>
<p>:	Requirements<br/>
:	Specifications<br/>
:	Design<br/>
:	Implementation<br/>
:	Integration<br/>
:	Maintenance<br/>
:	Retirement<br/>
</p>
<h3>Software Evolution Laws</h3>
<p>Lehman has given laws for software evolution. He divided the software into three different categories:</p>
<p>•	S-type (static-type) - This is a software, which works strictly according to defined specifications and solutions. <br/>The solution and the method to achieve it, both are immediately understood before coding.<br/> The s-type software is least subjected to changes hence this is the simplest of all. For example, calculator program for mathematical computation.</p> 
<p>•	P-type (practical-type) - This is a software with a collection of procedures. This is defined by exactly what procedures can do.<br/> In this software, the specifications can be described but the solution is not obvious instantly. For example, gaming software.</p>
<p>•	E-type (embedded-type) - This software works closely as the requirement of real-world environment. <br/>This software has a high degree of evolution as there are various changes in laws, taxes etc. in the real world situations. For example, Online trading software.</p>

<h4>E-Type software evolution </h4>
<p>Lehman has given eight laws for E-Type software evolution - </p>
<p>•	Continuing change - An E-type software system must continue to adapt to the real world changes, else it becomes progressively less useful.</p>
<p>•	Increasing complexity - As an E-type software system evolves, its complexity tends to increase unless work is done to maintain or reduce it.</p>
<p>•	Conservation of familiarity - The familiarity with the software or the knowledge about how it was developed, why was it developed in that particular manner etc. must be retained at any cost, to implement the changes in the system.</p>
<p>•	Continuing growth- In order for an E-type system intended to resolve some business problem, its size of implementing the changes grows according to the lifestyle changes of the business.</p>
<p>•	Reducing quality - An E-type software system declines in quality unless rigorously maintained and adapted to a changing operational environment.</p>
<p>•	Feedback systems- The E-type software systems constitute multi-loop, multi-level feedback systems and must be treated as such to be successfully modified or improved.</p>
<p>•	Self-regulation - E-type system evolution processes are self-regulating with the distribution of product and process measures close to normal.</p>
<p>•	Organizational stability - The average effective global activity rate in an evolving E-type system is invariant over the lifetime of the product.</p>

<h3>Software Paradigms</h3>
<p>Software paradigms refer to the methods and steps, which are taken while designing the software.<br/> There are many methods proposed and are in work today, but we need to see where in the software engineering these paradigms stand. These can be combined into various categories, though each of them is contained in one another:</p>
 <div class="erb-image-wrapper">
<img src="file:///android_asset/spara.png" alt="pradigms" />
</div>
<p>Programming paradigm is a subset of Software design paradigm which is further a subset of Software development paradigm.</p>

<h4>Software Development Paradigm</h4>
<p>This Paradigm is known as software engineering paradigms where all the engineering concepts pertaining to the development of software are applied.<br/> It includes various researches and requirement gathering which helps the software product to build. It consists of – </p>
<p>•	Requirement gathering<br/>
•	Software design <br/>
•	Programming<br/>
</p>
<h4>Software Design Paradigm</h4>
<p>This paradigm is a part of Software Development and includes – </p>
•	Design <br/>
•	Maintenance<br/>
•	Programming<br/>
<h4>Programming Paradigm</h4>
<p>This paradigm is related closely to programming aspect of software development. This includes –</p>
•	Coding <br/>
•	Testing<br/>
•	Integration<br/>

<h3>Need of Software Engineering</h3>
<p>The need of software engineering arises because of higher rate of change in user requirements and environment on which the software is working.</p>
<p>•	Large software - It is easier to build a wall than to a house or building, likewise, as the size of software become large engineering has to step to give it a scientific process.</p>
<p>•	Scalability- If the software process were not based on scientific and engineering concepts, it would be easier to re-create new software than to scale an existing one.</p>
<p>•	Cost- As hardware industry has shown its skills and huge manufacturing has lower down the price of computer and electronic hardware. But the cost of software remains high if proper process is not adapted.</p>
<p>•	Dynamic Nature- The always growing and adapting nature of software hugely depends upon the environment in which user works. <br/>If the nature of software is always changing, new enhancements need to be done in the existing one. This is where software engineering plays a good role.</p>
<p>•	Quality Management- Better process of software development provides better and quality software product.</p>

<h3>Attributes of Good Software</h3>
1	Attributes of software are not directly concerned with what the software does.<br/>
2	Reflect its behavior while it is executing and the structure and organization of the source program and associated documentation.
<br/>
3	Maintainability<br/>
4	Dependability<br/>
5	Efficiency<br/>
6	Usability<br/>
7	Other Attributes of Good Software<br/> 
8	Correctness <br/>
9	Reliability<br/>
10	Robustness <br/>
11	Performance<br/>
12	User Friendliness<br/>
13	Verifiability <br/>
14	Reusability<br/>
15	Repairability <br/>
16	Evolvability<br/>
17	Portability<br/>
18	Understandability<br/>
19	Interoperability<br/>
20	Productivity <br/>
21	Timeliness<br/>
22	Visibility<br/> 



	

	</body>
</html>