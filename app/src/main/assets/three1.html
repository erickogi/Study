<html>
	<meta charset="UTF-8">
	<style>
	
	  @font-face {
                    font-family: "ebrima";
                    src: url('file:///android_asset/fonts/ebrima.TTF');
                }
		body{
			font-family: ebrima, Tahoma, "Arial Black";
		    font-size: 16px;		    
		    word-wrap: normal;		
		}
		p{
			line-height:22px;
			padding-bottom:10px;			
		}
		h3, h4{
			font-family: ebrima, Tahoma, "Arial Black";
			color:#2c3e4c;
			padding-bottom:3px;
			border-bottom: 1px solid #444343;
			font-weight:650;
		}
		td{
			padding:10px;
			border: 1px solid #2c3e4c;
		}
		
		.erb-image-wrapper{
			max-width:100%;
            height:auto;
            position: relative;
            display:block;
            margin:0 auto;
        }
        
        .erb-image-wrapper img{
        	max-width:100% !important;
            height:auto;
            display:block;
         }	
	
</style>
   <body>
<h3>Software Evolution</h3>
<p>The process of developing a software product using software engineering principles and methods is referred to as software evolution.<br/> This includes the initial development of software and its maintenance and updates, till desired software product is developed, which satisfies the expected requirements.</p>
 <div class="erb-image-wrapper">
<img src="file:///android_asset/process.png" alt="process" />
</div>
<p>Evolution starts from the requirement gathering process. After which developers create a prototype of the intended software and show it to the users to get their feedback at the early stage of software product development.<br/> The users suggest changes, on which several consecutive updates and maintenance keep on changing too. <br/>This process changes to the original software, till the desired software is accomplished.</p>
<p>Even after the user has desired software in hand, the advancing technology and the changing requirements force the software product to change accordingly. <br/>Re-creating software from scratch and to go one-on-one with requirement is not feasible. <br/>The only feasible and economical solution is to update the existing software so that it matches the latest requirements.</p>
<h5>SUMMARY</h5>
<h3>SOFTWARE ENGINEERING LIFE CYCLE</h3>
<p>:	Requirements<br/>
:	Specifications<br/>
:	Design<br/>
:	Implementation<br/>
:	Integration<br/>
:	Maintenance<br/>
:	Retirement<br/>
</p>
<h3>Software Evolution Laws</h3>
<p>Lehman has given laws for software evolution. He divided the software into three different categories:</p>
<p>•	S-type (static-type) - This is a software, which works strictly according to defined specifications and solutions. <br/>The solution and the method to achieve it, both are immediately understood before coding.<br/> The s-type software is least subjected to changes hence this is the simplest of all. For example, calculator program for mathematical computation.</p> 
<p>•	P-type (practical-type) - This is a software with a collection of procedures. This is defined by exactly what procedures can do.<br/> In this software, the specifications can be described but the solution is not obvious instantly. For example, gaming software.</p>
<p>•	E-type (embedded-type) - This software works closely as the requirement of real-world environment. <br/>This software has a high degree of evolution as there are various changes in laws, taxes etc. in the real world situations. For example, Online trading software.</p>

<h4>E-Type software evolution </h4>
<p>Lehman has given eight laws for E-Type software evolution - </p>
<p>•	Continuing change - An E-type software system must continue to adapt to the real world changes, else it becomes progressively less useful.</p>
<p>•	Increasing complexity - As an E-type software system evolves, its complexity tends to increase unless work is done to maintain or reduce it.</p>
<p>•	Conservation of familiarity - The familiarity with the software or the knowledge about how it was developed, why was it developed in that particular manner etc. must be retained at any cost, to implement the changes in the system.</p>
<p>•	Continuing growth- In order for an E-type system intended to resolve some business problem, its size of implementing the changes grows according to the lifestyle changes of the business.</p>
<p>•	Reducing quality - An E-type software system declines in quality unless rigorously maintained and adapted to a changing operational environment.</p>
<p>•	Feedback systems- The E-type software systems constitute multi-loop, multi-level feedback systems and must be treated as such to be successfully modified or improved.</p>
<p>•	Self-regulation - E-type system evolution processes are self-regulating with the distribution of product and process measures close to normal.</p>
<p>•	Organizational stability - The average effective global activity rate in an evolving E-type system is invariant over the lifetime of the product.</p>
<br/>
   <br/>
   <br/>
   	</body>
</html>
